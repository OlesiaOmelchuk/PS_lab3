---
title: "R Notebook"
output:
  html_document:
    df_print: paged
---

# Task1

1.  Estimate numerically the probability ˆpn of the event that your TLN occurs in a random digit sequence d1d2d3 . . . dn.\
    Hint: Such a sequence can be generated with R command sample(0:9, n, replace=T); you will need to generate a sample of such sequences of sufficiently large size N\

```{r}
set.seed(15)
TLN = 015
K = 1000
counter <- c(0, 0, 0)
#N <- c(100, 150, 5)
N <- c(100, 200, 1000)
for (i in(1:K)){
  for (j in (1:3)){
    n <- N[j]
    rand_sample <- c(sample(0:9, n, replace=T))
    #print(rand_sample)
    my_range <- 1:(n-3)
    for (index in my_range){
      dig1 <- rand_sample[index]
      dig2 <- rand_sample[index+1]
      dig3 <- rand_sample[index+2]
      if (dig1 == 0 && dig2 == 1 && dig3 == 5){
        counter[j] = counter[j] + 1
        break
      }
    }
  }
}
prob <- c(counter[1]/K, counter[2]/K,counter[3]/K)

cat("The probabilty that TLN occurs in a random sequence of digits of length 100:\n", prob[1], "\n\n")
cat("The probabilty that TLN occurs in a random sequence of digits of length 200:\n", prob[2], "\n\n")
cat("The probabilty that TLN occurs in a random sequence of digits of length 1000:\n", prob[3], "\n\n")
```

2.  Identify the the Markov chain structure with four states S0, S1, S2, S3 in this sequence with Sk denoting the number of correct last digits (id = 015 -\> S0 ="\*", S1 ="0", S2 ="01", S3 ="015"). Determine the transition probabilities matrix P and find the limiting probability pn for the state "015"

The transition probabilities matrix P: $$
P = 
\begin{pmatrix}
0.9 & 0.1 & 0 & 0\\
0.8 & 0.1 & 0.1 & 0\\
0.8 & 0.1 & 0 & 0.1\\
0.9 & 0.1 & 0 & 0\\
\end{pmatrix}
$$ Solving limiting probability $$
{\pi_0 = 0.9 \pi_0 + 0.8\pi_1 + 0.8\pi_2 + 0.9\pi_3\\
\pi_1 = 0.1\pi_0 + 0.1\pi_1 + 0.1\pi_2 + 0.1\pi_3\\
\pi_2 = 0.1\pi_1\\
\pi_3 = 0.1\pi_2\\
\pi_0 + \pi_1 + \pi_2 + \pi_3 = 1}
$$ Solution:$$
{\pi_0 = 0.889\\
\pi_1 = 0.1\\
\pi_2 = 0.01\\
\pi_3 = 0.001}
$$

3.  Determine approximately the sample size N which guarantees that the absolute error \| $\hat{p_n} − p_n$\| of the estimate $\hat{p_n}$ is below 0.03 with confidence level of at least 95 percent. Rerun the experiments for n = 1000 with the determined size N to illustrate the confidence interval and confidence level. Hint: estimate the standard deviation of the corresponding random variable by the standard error of the sample.

# Task2

In the setting of Problem 1, assume that the random digit generation stops at the first occurrence of the TLN (i.e., that the state S4 of the Markov chain is now absorbing). In this problem, you will estimate the average length of such sequences (i.e., the average time till absorption in the Markov chain).

1.  Make necessary amendments to the transition probabilities matrix P above and solve the corresponding system to find the expected time E(T) till absorption

The transition probabilities matrix P: $$  
    P = 
    \begin{pmatrix}
        0.9 & 0.1 & 0 & 0\\
        0.8 & 0.1 & 0.1 & 0\\
        0.8 & 0.1 & 0 & 0.1\\
        0 & 0 & 0 & 1\\
    \end{pmatrix}
$$ Solving a system to find the expected time E(T) till absorption

$${\mu_0 = 1 + 0.9 \mu_0 + 0.1\mu_1\\
\mu_1 = 1 + 0.8\mu_0 + 0.1\mu_1 + 0.1\mu_2\\
\mu_2 = 1 + 0.8\mu_0 + 0.1\mu_1 + 0.1\mu_3\\
\mu_3 = 0}
$$ Solution: $$
{\mu_0 = 1000\\
\mu_1 = 990\\
\mu_2 = 900\\
\mu_3 = 0}
$$ As we can see, $\mu_0 = 1000$, so $E(T) = 1000$

2.  Estimate numerically the expected length E(T) till the first occurrence of the TLN by running a sufficiently large number N of experiments. Hint: Clearly, the unbiased estimator for θ := E(T) is the sample mean $\hat{\theta} = \overline{T} = \frac{1}{N}*(T_1 + T_2 + ... + T_N)$

```{r}
set.seed(15)
N = 2000
total_sum = 0
for (i in (1:N)){
  rand_sample <- c(sample(0:9, 3, replace=T))
  i = 3
  while(rand_sample[i-2] != 0 | rand_sample[i-1] != 1 | rand_sample[i] != 5){
    rand_sample <- c(rand_sample, sample(0:9, 1, replace=T))
    i = i+1
  }
  total_sum = total_sum + length(rand_sample)
}

exp_time = total_sum/N
print(exp_time)
```

As we can see, in practice E(T) = 1006.792. This is very close to the theoretical value we found above

3.  Find the sample size N which guarantees that the absolute error \|ˆθ − θ\| of the estimate does not exceed 10 with confidence level of at least 95 percent. Hint: use Chebyshev inequality and estimate the standard deviation of T by the standard error of the sample T1, T2, . . . , TN


# Task 4

Repeat parts (2)–(4) of Problem 3 (with corresponding amendments) for a Poisson distribution P(θ).
Task and Directions remain he same; in other words, you have to check that confidence intervals constructed there
contain the parameter θ with prescribed probability.
```{r}
set.seed(15)

lambda = 5

matrix_size =  c(100, 1000, 10000)

success_count = 0

print_result <- function(lower, upper, sample_mean) {
  cat("For confidence level", 1 - a, "where n =", n, ":\n")
    cat("    CI is [", lower, ",", upper, "]\n")
    cat("    The fraction of CI's containing the parameter is", length(sample_mean[lower <= sample_mean & sample_mean <= upper]) / n, "\n\n\n")
}

#(2)
for (n in matrix_size) {
  x <- matrix(rpois(n*n, lambda), nrow = n)
  sample_mean <- colMeans(x)
  sample_sd <- sd(x)
  
  for (a in c(0.1, 0.05, 0.01)) {
    lower <- mean(sample_mean) - qnorm(1 - a/2) * sample_sd / sqrt((n))

    upper <- mean(sample_mean) + qnorm(1 - a/2) * sample_sd / sqrt((n))
    
    print_result(lower, upper, sample_mean)
  }

}
```
(3)
```{r}
#(3)
for (n in matrix_size) {
  x <- matrix(rpois(n*n, lambda), nrow = n)
  sample_mean <- colMeans(x)
  sample_sd <- sd(x)
  
  for (a in c(0.1, 0.05, 0.01)) {
    #lower <- (mean(sample_mean) * sqrt(n)) / (sqrt(n) + qnorm(1-a/2))

    #upper <- (mean(sample_mean) * sqrt(n)) / (sqrt(n)- qnorm(1-a/2))
    
    discriminant <- qnorm(1 - a/2) / n + 4 * mean(sample_mean)
    
    lower <-(sqrt(discriminant)/2 - qnorm(1-a/2)/(2*sqrt(n)))^2
    
    upper <- (sqrt(discriminant)/2 + qnorm(1-a/2)/(2*sqrt(n)))^2
    
    print_result(lower, upper, sample_mean)
  }
}

```

(4)
```{r}
#(4)
for (n in matrix_size) {
  x <- matrix(rpois(n*n, lambda), nrow = n)
  sample_mean <- colMeans(x)
  sample_sd <- sd(x)

  for (a in c(0.1, 0.05, 0.01)) {
    
    lower <- mean(sample_mean) - sample_sd * qt(1-a/2, n - 1) / sqrt(n)
    
    upper <- mean(sample_mean) + sample_sd * qt(1-a/2, n - 1) / sqrt(n)
    
    print_result(lower, upper, sample_mean)
  }
}

```